
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <title>Code Documentation &#8212; QuantumPolyspectra  documentation</title>
    <link rel="stylesheet" href="_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/language_data.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="prev" title="Welcome to QuantumPolyspectra’s documentation!" href="index.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <div class="section" id="module-QuantumPolyspectra.simulation">
<span id="code-documentation"></span><h1>Code Documentation<a class="headerlink" href="#module-QuantumPolyspectra.simulation" title="Permalink to this headline">¶</a></h1>
<dl class="py class">
<dt id="QuantumPolyspectra.simulation.System">
<em class="property">class </em><code class="sig-prename descclassname">QuantumPolyspectra.simulation.</code><code class="sig-name descname">System</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">h</span></em>, <em class="sig-param"><span class="n">psi_0</span></em>, <em class="sig-param"><span class="n">c_ops</span></em>, <em class="sig-param"><span class="n">sc_ops</span></em>, <em class="sig-param"><span class="n">e_ops</span></em>, <em class="sig-param"><span class="n">c_measure_strength</span></em>, <em class="sig-param"><span class="n">sc_measure_strength</span></em><span class="sig-paren">)</span><a class="headerlink" href="#QuantumPolyspectra.simulation.System" title="Permalink to this definition">¶</a></dt>
<dd><p>Class that will represent the system of interest. It contains the parameters of the system and the
methods for calculating and storing the polyspectra.</p>
<dl class="simple">
<dt>h<span class="classifier">Qobj</span></dt><dd><p>Hamiltonian of the system.</p>
</dd>
<dt>psi_0<span class="classifier">Qobj</span></dt><dd><p>Initial state of the system for the integration of the SME.</p>
</dd>
<dt>c_ops<span class="classifier">dict</span></dt><dd><p>Dictionary containing the collaps operators (as Qobj) with arbitrary str as keys.</p>
</dd>
<dt>sc_ops<span class="classifier">dict</span></dt><dd><p>Dictionary containing the stochastic collaps operators (as Qobj) with arbitrary str as keys.</p>
</dd>
<dt>e_ops<span class="classifier">dict</span></dt><dd><p>Dictionary containing the operators (as Qobj) used for the calculation of the
expectation values with arbitrary str as keys.</p>
</dd>
<dt>c_measure_strength<span class="classifier">dict</span></dt><dd><p>Dictionary containing the prefactor (float) of the collaps operators. Should have the same
keys as the corresponding collaps operators in c_ops.</p>
</dd>
<dt>sc_measure_strength<span class="classifier">dict</span></dt><dd><p>Dictionary containing the prefactor (float) of the stochastic collaps operators. Should have the same
keys as the corresponding collaps operators in sc_ops.</p>
</dd>
</dl>
<dl class="simple">
<dt>H<span class="classifier">array</span></dt><dd><p>Hamiltonian of the system</p>
</dd>
<dt>L<span class="classifier">array</span></dt><dd><p>Liouvillian of the system</p>
</dd>
<dt>psi_0: array</dt><dd><p>Start state for the integration of the stochastic master equation</p>
</dd>
<dt>c_ops<span class="classifier">dict</span></dt><dd><p>Dictionary containing the collaps operators (as Qobj) with arbitrary str as keys.</p>
</dd>
<dt>sc_ops<span class="classifier">dict</span></dt><dd><p>Dictionary containing the stochastic collaps operators (as Qobj) with arbitrary str as keys.</p>
</dd>
<dt>e_ops<span class="classifier">dict</span></dt><dd><p>Dictionary containing the operators (as Qobj) used for the calculation of the
expectation values with arbitrary str as keys.</p>
</dd>
<dt>c_measure_strength<span class="classifier">dict</span></dt><dd><p>Dictionary containing the prefactor (float) of the collaps operators. Should have the same
keys as the corresponding collaps operators in c_ops.</p>
</dd>
<dt>sc_measure_strength<span class="classifier">dict</span></dt><dd><p>Dictionary containing the prefactor (float) of the stochastic collaps operators. Should have the same
keys as the corresponding collaps operators in sc_ops.</p>
</dd>
<dt>time_series_data_empty<span class="classifier">dataframe</span></dt><dd><p>Empty version of the simulation results dataframe to reset any results.</p>
</dd>
<dt>time_series_data<span class="classifier">dataframe</span></dt><dd><p>Stores expectation values after the integration of the SME</p>
</dd>
<dt>freq<span class="classifier">dict</span></dt><dd><p>Stores the frequencies from the analytic spectra, order 2 to 4</p>
</dd>
<dt>S<span class="classifier">dict</span></dt><dd><p>Stores the analytic spectra, order 2 to 4</p>
</dd>
<dt>numeric_f_data<span class="classifier">dict</span></dt><dd><p>Stores the frequencies from the numeric spectra, order 2 to 4</p>
</dd>
<dt>numeric_spec_data<span class="classifier">dict</span></dt><dd><p>Stores the numeric spectra, order 2 to 4</p>
</dd>
<dt>eigvals<span class="classifier">array</span></dt><dd><p>Stores eigenvalues of Liouvillian</p>
</dd>
<dt>eigvecs<span class="classifier">array</span></dt><dd><p>Stores eigenvectors of Liouvillian</p>
</dd>
<dt>eigvecs_inv<span class="classifier">array</span></dt><dd><p>Stores the matrix inversion of the eigenvector matrix</p>
</dd>
<dt>zero_ind<span class="classifier">int</span></dt><dd><p>Contains the index of the steady state in the eigvalues</p>
</dd>
<dt>A_prim<span class="classifier">array</span></dt><dd><p>Stores the measurement superoperator mathcal{A} as defined in 10.1103/PhysRevB.98.205143</p>
</dd>
<dt>rho_steady<span class="classifier">array</span></dt><dd><p>Steady state of the Liouvillian</p>
</dd>
<dt>s_k<span class="classifier">array</span></dt><dd><p>Stores small s (Eq. 7) from 10.1103/PhysRevB.102.119901</p>
</dd>
<dt>expect_data<span class="classifier">dict</span></dt><dd><p>Stores expectation values calculated during the integration of the SME (daemon view), keys as in e_ops</p>
</dd>
<dt>expect_with_noise<span class="classifier">dict</span></dt><dd><p>Stores expectation + detector noise values calculated during the integration of the SME, keys as in e_ops</p>
</dd>
<dt>N<span class="classifier">int</span></dt><dd><p>Number of points in time series in window for the calculation of numerical spectra</p>
</dd>
<dt>fs<span class="classifier">float</span></dt><dd><p>Sampling rate of the simulated signal for numerical spectra</p>
</dd>
<dt>a_w<span class="classifier">array</span></dt><dd><p>Fourier coefficients of simulated signal for numerical spectra</p>
</dd>
<dt>a_w_cut<span class="classifier">array</span></dt><dd><p>Contains only the frequencies of interest from a_w (to speed up calculations)</p>
</dd>
<dt>enable_gpu<span class="classifier">bool</span></dt><dd><p>Set if GPU should be used for analytic spectra calculation</p>
</dd>
<dt>gpu_0<span class="classifier">int</span></dt><dd><p>Stores pointer to zero an the GPU</p>
</dd>
<dt>reshape_ind: array</dt><dd><p>Extracts the trace from a flatted matrix (to avoid reshaping)</p>
</dd>
</dl>
<dl class="py method">
<dt id="QuantumPolyspectra.simulation.System.calc_a_w3">
<code class="sig-name descname">calc_a_w3</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">a_w</span></em><span class="sig-paren">)</span><a class="headerlink" href="#QuantumPolyspectra.simulation.System.calc_a_w3" title="Permalink to this definition">¶</a></dt>
<dd><p>Preparation of a_(w1+w2) for the calculation of the bispectrum</p>
<dl class="simple">
<dt>a_w<span class="classifier">array</span></dt><dd><p>Fourier coefficients of signal</p>
</dd>
</dl>
<dl class="simple">
<dt>a_w3<span class="classifier">array</span></dt><dd><p>Matrix corresponding to a_(w1+w2)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="QuantumPolyspectra.simulation.System.calc_spectrum">
<code class="sig-name descname">calc_spectrum</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">f_data</span></em>, <em class="sig-param"><span class="n">order</span></em>, <em class="sig-param"><span class="n">measure_op</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">mathcal_a</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">g_prim</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">bar</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">beta</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">correction_only</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">beta_offset</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">enable_gpu</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">cache_trispec</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="headerlink" href="#QuantumPolyspectra.simulation.System.calc_spectrum" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates analytic polyspectra (order 2 to 4) as described in 10.1103/PhysRevB.98.205143
and 10.1103/PhysRevB.102.119901</p>
<dl class="simple">
<dt>f_data<span class="classifier">array</span></dt><dd><p>Frequencies at which the spectra are calculated</p>
</dd>
<dt>order<span class="classifier">int {2,3,4}</span></dt><dd><p>Order of the polyspectra to be calculated</p>
</dd>
<dt>measure_op<span class="classifier">str</span></dt><dd><p>Key of the operator in sc_ops to be used as measurement operator</p>
</dd>
<dt>mathcal_a<span class="classifier">array</span></dt><dd><p>Stores the measurement superoperator mathcal{A} as defined in 10.1103/PhysRevB.98.205143</p>
</dd>
<dt>g_prim<span class="classifier">bool</span></dt><dd><p>Set if mathcal_a should be applied twice/squared (was of use when defining the current operator)
But unnecessary for standard polyspectra</p>
</dd>
<dt>bar<span class="classifier">bool</span></dt><dd><p>Set if progress bars should be shown during calculation</p>
</dd>
<dt>beta<span class="classifier">float</span></dt><dd><p>Measurement strength used for the calculation. If not set beta is the prefactor
in sc_measure_strength[measure_op]</p>
</dd>
<dt>correction_only<span class="classifier">bool</span></dt><dd><p>Set if only the correction terms of the S4 from erratum 10.1103/PhysRevB.102.119901 should be
calculated</p>
</dd>
<dt>beta_offset<span class="classifier">bool</span></dt><dd><p>Set if constant offset due to deetector noise should be added to the power spectrum</p>
</dd>
<dt>enable_gpu<span class="classifier">bool</span></dt><dd><p>Set if GPU should be used for calculation</p>
</dd>
<dt>cache_trispec<span class="classifier">bool</span></dt><dd><p>Set if Matrix multiplication in the calculation of the trispectrum should be cached</p>
</dd>
</dl>
<dl class="simple">
<dt>S[order]<span class="classifier">array</span></dt><dd><p>Returns spectral value at specified frequencies</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="QuantumPolyspectra.simulation.System.calc_transient">
<code class="sig-name descname">calc_transient</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">t</span></em>, <em class="sig-param"><span class="n">seed</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">_solver</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">progress_bar</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">_nsubsteps</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">_normalize</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">options</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">return_result</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#QuantumPolyspectra.simulation.System.calc_transient" title="Permalink to this definition">¶</a></dt>
<dd><p>Integrate the SME for the system definined by mathcal{L} and the starting state rho_0. Saves the
results (daemon view and measurement with detector noise) in a dataframe</p>
<dl>
<dt>t<span class="classifier">array</span></dt><dd><p>Times at which the SME is intergrated</p>
</dd>
<dt>seed<span class="classifier">int</span></dt><dd><blockquote>
<div><p>Seed for the generation of the Wiener Process</p>
</div></blockquote>
<dl class="simple">
<dt>_solver<span class="classifier">str</span></dt><dd><p>Name of the solver used for the intergration of the SME (see the qutip docs for more information)</p>
</dd>
</dl>
</dd>
<dt>_nsubsteps<span class="classifier">int</span></dt><dd><p>Number of substeps between to point in t. Reduces numerical errors.</p>
</dd>
<dt>_normalize<span class="classifier">bool</span></dt><dd><p>Set if density matrix should be normalized after each integration step</p>
</dd>
<dt>progress_bar<span class="classifier">bool</span></dt><dd><p>Set if progress bar should be shown during integration</p>
</dd>
<dt>options<span class="classifier">dict</span></dt><dd><p>Solver options (see qutip documentation)</p>
</dd>
<dt>return_result<span class="classifier">bool</span></dt><dd><p>Set if solver result should be returned in addition to the dataframe</p>
</dd>
</dl>
<p>Return a dataframe containing the daemon view and measurement with detector noise.
Additionally, returns solver result (see return_result parameter)</p>
</dd></dl>

<dl class="py method">
<dt id="QuantumPolyspectra.simulation.System.first_matrix_step">
<code class="sig-name descname">first_matrix_step</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">rho</span></em>, <em class="sig-param"><span class="n">omega</span></em><span class="sig-paren">)</span><a class="headerlink" href="#QuantumPolyspectra.simulation.System.first_matrix_step" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper method to move function out of the class. njit is not working within classes</p>
</dd></dl>

<dl class="py method">
<dt id="QuantumPolyspectra.simulation.System.fourier_g_prim">
<code class="sig-name descname">fourier_g_prim</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">omega</span></em><span class="sig-paren">)</span><a class="headerlink" href="#QuantumPolyspectra.simulation.System.fourier_g_prim" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper method to move function out of the class. njit is not working within classes</p>
</dd></dl>

<dl class="py method">
<dt id="QuantumPolyspectra.simulation.System.g_prim">
<code class="sig-name descname">g_prim</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">t</span></em><span class="sig-paren">)</span><a class="headerlink" href="#QuantumPolyspectra.simulation.System.g_prim" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper method to move function out of the class. njit is not working within classes</p>
</dd></dl>

<dl class="py method">
<dt id="QuantumPolyspectra.simulation.System.matrix_step">
<code class="sig-name descname">matrix_step</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">rho</span></em>, <em class="sig-param"><span class="n">omega</span></em><span class="sig-paren">)</span><a class="headerlink" href="#QuantumPolyspectra.simulation.System.matrix_step" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper method to move function out of the class. njit is not working within classes</p>
</dd></dl>

<dl class="py method">
<dt id="QuantumPolyspectra.simulation.System.numeric_spec">
<code class="sig-name descname">numeric_spec</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">t_window_in</span></em>, <em class="sig-param"><span class="n">measure_op</span></em>, <em class="sig-param"><span class="n">f_max</span></em>, <em class="sig-param"><span class="n">power</span></em>, <em class="sig-param"><span class="n">order</span></em>, <em class="sig-param"><span class="n">max_samples</span></em>, <em class="sig-param"><span class="n">m</span><span class="o">=</span><span class="default_value">5</span></em>, <em class="sig-param"><span class="n">_solver</span><span class="o">=</span><span class="default_value">'milstein'</span></em>, <em class="sig-param"><span class="n">plot_after</span><span class="o">=</span><span class="default_value">12</span></em>, <em class="sig-param"><span class="n">title_in</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">with_noise</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">_normalize</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">roll</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">plot_simulation</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">backend</span><span class="o">=</span><span class="default_value">'opencl'</span></em><span class="sig-paren">)</span><a class="headerlink" href="#QuantumPolyspectra.simulation.System.numeric_spec" title="Permalink to this definition">¶</a></dt>
<dd><p>Method for the automated calculation of the polyspectra from the numerical integration of the SME.
Can be used as an alternative to the analytic quantum polyspectra or to estimated measurement time and
noise levels of the spectra.</p>
<dl class="simple">
<dt>t_window_in<span class="classifier">array</span></dt><dd><p>Times at with the SME will be integrated</p>
</dd>
<dt>measure_op<span class="classifier">str</span></dt><dd><p>Key of the operator in sc_ops that should be used as measurement operator</p>
</dd>
<dt>f_max<span class="classifier">float</span></dt><dd><p>Maximum frequency of interest to speed up calculation of polyspectra</p>
</dd>
<dt>power<span class="classifier">float</span></dt><dd><p>Power to which the detector output should be raised before the calculation of the spectra
(Was useful during the experimentation with the current operator.)</p>
</dd>
<dt>order<span class="classifier">int {2,3,4}</span></dt><dd><p>Order of the polyspectra to be calculated</p>
</dd>
<dt>max_samples<span class="classifier">int</span></dt><dd><p>Number of spectra with m windows to be calculated. The final result will be an average over all these
spectra</p>
</dd>
<dt>m<span class="classifier">int</span></dt><dd><p>number of frames used from the calculation of one spectrum</p>
</dd>
<dt>_solver<span class="classifier">str</span></dt><dd><p>Name of the solver used for the intergration of the SME (see the qutip docs for more information)</p>
</dd>
<dt>plot_after<span class="classifier">int</span></dt><dd><p>Each number of spectra after with the current average spectrum should be displayed</p>
</dd>
<dt>title_in<span class="classifier">str</span></dt><dd><p>Add a str to customize title</p>
</dd>
<dt>with_noise<span class="classifier">bool</span></dt><dd><p>Set if detector output with noise should be used for the calculation of the spectra instead of
the daemon view</p>
</dd>
<dt>_normalize<span class="classifier">bool</span></dt><dd><p>Set if density matrix should be normalized during integration of the SME</p>
</dd>
<dt>roll<span class="classifier">bool</span></dt><dd><p>Set if trace should be shifted against itself during squaring</p>
</dd>
<dt>plot_simulation<span class="classifier">bool</span></dt><dd><p>Set if simulation result / trace should be plot. Useful to check for numerical errors during integration</p>
</dd>
<dt>backend<span class="classifier">str {cpu, opencl, cuda}</span></dt><dd><p>Backend to be used by arrayfire</p>
</dd>
</dl>
<p>Return frequencies and the spectral values as arrays</p>
</dd></dl>

<dl class="py method">
<dt id="QuantumPolyspectra.simulation.System.parallel_tranisent">
<code class="sig-name descname">parallel_tranisent</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">seed</span></em>, <em class="sig-param"><span class="n">measure_op</span></em>, <em class="sig-param"><span class="n">t</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">_solver</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">with_noise</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">_nsubsteps</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">_normalize</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#QuantumPolyspectra.simulation.System.parallel_tranisent" title="Permalink to this definition">¶</a></dt>
<dd><p>Method for the quick integration of the SME (avoids saving the results into dataframes). Is used for
parallelization of the integration.</p>
<dl class="simple">
<dt>seed<span class="classifier">int</span></dt><dd><p>Seed for the generation of random numbers for the Wiener process</p>
</dd>
<dt>measure_op<span class="classifier">str</span></dt><dd><p>Key of the measurement operator in sc_ops</p>
</dd>
<dt>t<span class="classifier">array</span></dt><dd><p>Times at which the integration takes place</p>
</dd>
<dt>_solver<span class="classifier">str</span></dt><dd><p>Name of the solver used for the intergration of the SME (see the qutip docs for more information)</p>
</dd>
<dt>with_noise<span class="classifier">bool</span></dt><dd><p>Set if detector noise should be added to the trace</p>
</dd>
<dt>_nsubsteps<span class="classifier">int</span></dt><dd><p>Number of substeps between to point in t. Reduces numerical errors.</p>
</dd>
<dt>_normalize<span class="classifier">bool</span></dt><dd><p>Set if density matrix should be normalized after each integration step</p>
</dd>
</dl>
<dl class="simple">
<dt>out<span class="classifier">array</span></dt><dd><p>Simulated detector output</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="QuantumPolyspectra.simulation.System.plot_all">
<code class="sig-name descname">plot_all</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">f_max</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#QuantumPolyspectra.simulation.System.plot_all" title="Permalink to this definition">¶</a></dt>
<dd><p>Method for quick plotting of polyspectra</p>
<dl class="simple">
<dt>f_max<span class="classifier">float</span></dt><dd><p>Maximum frequencies upto which the spectra should be plotted</p>
</dd>
</dl>
<p>Returns matplotlib figure</p>
</dd></dl>

<dl class="py method">
<dt id="QuantumPolyspectra.simulation.System.plot_spectrum">
<code class="sig-name descname">plot_spectrum</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">order</span></em>, <em class="sig-param"><span class="n">title</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">log</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">x_range</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">imag_plot</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#QuantumPolyspectra.simulation.System.plot_spectrum" title="Permalink to this definition">¶</a></dt>
<dd><p>Method for the visualization of single spectra with an interactive plot</p>
<dl class="simple">
<dt>order<span class="classifier">int {2,3,4}</span></dt><dd><p>Order of polyspectrum to be plotted</p>
</dd>
<dt>title<span class="classifier">str</span></dt><dd><p>Title of the plot</p>
</dd>
<dt>log<span class="classifier">bool</span></dt><dd><p>Set if log scales should be used</p>
</dd>
<dt>x_range<span class="classifier">array</span></dt><dd><p>Sets limits of x axis</p>
</dd>
<dt>imag_plot<span class="classifier">bool</span></dt><dd><p>Set if imaginary of the spectrum should be shown</p>
</dd>
</dl>
<p>Returns plotly figure</p>
</dd></dl>

<dl class="py method">
<dt id="QuantumPolyspectra.simulation.System.plot_transient">
<code class="sig-name descname">plot_transient</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">ops_with_power</span></em>, <em class="sig-param"><span class="n">title</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">shift</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#QuantumPolyspectra.simulation.System.plot_transient" title="Permalink to this definition">¶</a></dt>
<dd><p>Interactive plot of the integration results.</p>
<dl class="simple">
<dt>ops_with_power<span class="classifier">dict</span></dt><dd><p>Key of the operators in e_ops as key with integer labels corresponding the exponent to with the
corresponding trace should be raised to. (Was useful during the experimentation with the current operator.)</p>
</dd>
<dt>title<span class="classifier">str</span></dt><dd><p>Title of plot</p>
</dd>
<dt>shift<span class="classifier">bool</span></dt><dd><p>Set if traces should be shifted up to avoid overlapping of multiple traces</p>
</dd>
</dl>
<p>Plotly figure</p>
</dd></dl>

<dl class="py method">
<dt id="QuantumPolyspectra.simulation.System.save_spec">
<code class="sig-name descname">save_spec</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">path</span></em><span class="sig-paren">)</span><a class="headerlink" href="#QuantumPolyspectra.simulation.System.save_spec" title="Permalink to this definition">¶</a></dt>
<dd><p>Save System class with spectral data</p>
<dl class="simple">
<dt>path<span class="classifier">str</span></dt><dd><p>Location of file</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="QuantumPolyspectra.simulation.System.second_matrix_step">
<code class="sig-name descname">second_matrix_step</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">rho</span></em>, <em class="sig-param"><span class="n">omega</span></em>, <em class="sig-param"><span class="n">omega2</span></em><span class="sig-paren">)</span><a class="headerlink" href="#QuantumPolyspectra.simulation.System.second_matrix_step" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper method to move function out of the class. njit is not working within classes</p>
</dd></dl>

<dl class="py method">
<dt id="QuantumPolyspectra.simulation.System.single_plot">
<code class="sig-name descname">single_plot</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">order</span></em>, <em class="sig-param"><span class="n">f_max</span></em>, <em class="sig-param"><span class="n">f_min</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">arcsinh_plot</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">arcsinh_const</span><span class="o">=</span><span class="default_value">0.02</span></em>, <em class="sig-param"><span class="n">contours</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">s3_filter</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">s4_filter</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">s2_data</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">s3_data</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">s4_data</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">s2_f</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">s3_f</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">s4_f</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">imag_plot</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">title</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#QuantumPolyspectra.simulation.System.single_plot" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates plot of the polyspectum of order “order”</p>
<dl class="simple">
<dt>order<span class="classifier">int {2,3,4}</span></dt><dd><p>Order of polyspectrum to be plotted</p>
</dd>
<dt>f_max<span class="classifier">float</span></dt><dd><p>Maximum value of frequency axis</p>
</dd>
<dt>f_min<span class="classifier">float</span></dt><dd><p>Minimum value of frequency axis</p>
</dd>
<dt>arcsinh_plot<span class="classifier">bool</span></dt><dd><p>Set if spectral values should be scaled by an arcsinh function (improves visability of small features)</p>
</dd>
<dt>arcsinh_const<span class="classifier">float</span></dt><dd><p>Constant to customize the effenct of the scaling</p>
</dd>
<dt>contours<span class="classifier">bool</span></dt><dd><p>Set if contours should be shown in the 2D plots</p>
</dd>
<dt>s3_filter<span class="classifier">int</span></dt><dd><p>Width of the Gaussian filter applied to the S3</p>
</dd>
<dt>s4_filter<span class="classifier">int</span></dt><dd><p>Width of the Gaussian filter applied to the S4</p>
</dd>
<dt>s2_data<span class="classifier">array</span></dt><dd><p>Spectral data for the S2</p>
</dd>
<dt>s3_data<span class="classifier">array</span></dt><dd><p>Spectral data for the S3</p>
</dd>
<dt>s4_data<span class="classifier">array</span></dt><dd><p>Spectral data for the S4</p>
</dd>
<dt>s2_f<span class="classifier">array</span></dt><dd><p>Frequencies corresponding to the spectral data of the S2</p>
</dd>
<dt>s3_f<span class="classifier">array</span></dt><dd><p>Frequencies corresponding to the spectral data of the S3</p>
</dd>
<dt>s4_f<span class="classifier">array</span></dt><dd><p>Frequencies corresponding to the spectral data of the S4</p>
</dd>
<dt>imag_plot<span class="classifier">bool</span></dt><dd><p>Set if imaginary part of the spectrum should be plotted</p>
</dd>
<dt>title<span class="classifier">set</span></dt><dd><p>Title of the plot</p>
</dd>
</dl>
<p>Matplotlib figure</p>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt id="QuantumPolyspectra.simulation.calc_liou">
<code class="sig-prename descclassname">QuantumPolyspectra.simulation.</code><code class="sig-name descname">calc_liou</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">rho_</span></em>, <em class="sig-param"><span class="n">h</span></em>, <em class="sig-param"><span class="n">c_ops_</span></em><span class="sig-paren">)</span><a class="headerlink" href="#QuantumPolyspectra.simulation.calc_liou" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the outcome of applying the Liouvillain to the density matrix. Use to calculated the
superoperator form of the Liouvillian.</p>
<dl class="simple">
<dt><a href="#id1"><span class="problematic" id="id2">rho_</span></a><span class="classifier">array</span></dt><dd><p>Test states ([1,0,0,……]) as inputs</p>
</dd>
<dt>h<span class="classifier">array</span></dt><dd><p>Hamilton operator</p>
</dd>
<dt><a href="#id3"><span class="problematic" id="id4">c_ops_</span></a><span class="classifier">array</span></dt><dd><p>Collapse operators for the Lindblad dampers</p>
</dd>
</dl>
<dl class="simple">
<dt>liou<span class="classifier">array</span></dt><dd><p>mathcal{L} &#64; <a href="#id5"><span class="problematic" id="id6">rho_</span></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="QuantumPolyspectra.simulation.calc_super_A">
<code class="sig-prename descclassname">QuantumPolyspectra.simulation.</code><code class="sig-name descname">calc_super_A</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">op</span></em><span class="sig-paren">)</span><a class="headerlink" href="#QuantumPolyspectra.simulation.calc_super_A" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the super operator of A as defined in 10.1103/PhysRevB.98.205143</p>
<dl class="simple">
<dt>op<span class="classifier">array</span></dt><dd><p>Operator a for the calculation of A[a]</p>
</dd>
</dl>
<dl class="simple">
<dt>op_super<span class="classifier">array</span></dt><dd><p>Superoperator A</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="QuantumPolyspectra.simulation.calc_super_liou">
<code class="sig-prename descclassname">QuantumPolyspectra.simulation.</code><code class="sig-name descname">calc_super_liou</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">h_</span></em>, <em class="sig-param"><span class="n">c_ops</span></em><span class="sig-paren">)</span><a class="headerlink" href="#QuantumPolyspectra.simulation.calc_super_liou" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculated the superoperator form of the Liouvillian, by checking one basis state of the desity matrix
after the other: [1,0,0…], [0,1,0,0,….], …</p>
<dl class="simple">
<dt><a href="#id7"><span class="problematic" id="id8">h_</span></a><span class="classifier">array</span></dt><dd><p>Hamilton operator</p>
</dd>
<dt>c_ops<span class="classifier">array</span></dt><dd><p>Collapse operators for the Lindblad dampers</p>
</dd>
</dl>
<dl class="simple">
<dt>op_super<span class="classifier">array</span></dt><dd><p>Superoperator form of the Liouvillian</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="QuantumPolyspectra.simulation.cgw">
<code class="sig-prename descclassname">QuantumPolyspectra.simulation.</code><code class="sig-name descname">cgw</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">len_y</span></em><span class="sig-paren">)</span><a class="headerlink" href="#QuantumPolyspectra.simulation.cgw" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates an array corresponding to the approx. confined gaussian window function</p>
<dl class="simple">
<dt>len_y<span class="classifier">int</span></dt><dd><p>Length of the window</p>
</dd>
</dl>
<p>window : array</p>
</dd></dl>

<dl class="py function">
<dt id="QuantumPolyspectra.simulation.pickle_save">
<code class="sig-prename descclassname">QuantumPolyspectra.simulation.</code><code class="sig-name descname">pickle_save</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">path</span></em>, <em class="sig-param"><span class="n">obj</span></em><span class="sig-paren">)</span><a class="headerlink" href="#QuantumPolyspectra.simulation.pickle_save" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper function to pickle system objects</p>
<dl class="simple">
<dt>path<span class="classifier">str</span></dt><dd><p>Location of saved data</p>
</dd>
</dl>
<p>obj : System obj</p>
</dd></dl>

<dl class="py function">
<dt id="QuantumPolyspectra.simulation.plotly">
<code class="sig-prename descclassname">QuantumPolyspectra.simulation.</code><code class="sig-name descname">plotly</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em>, <em class="sig-param"><span class="n">y</span></em>, <em class="sig-param"><span class="n">title</span></em>, <em class="sig-param"><span class="n">domain</span></em>, <em class="sig-param"><span class="n">order</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">y_label</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">x_label</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">legend</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">filter_window</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#QuantumPolyspectra.simulation.plotly" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper function for easy plotting with plotly.</p>
<p>x : array
y : array
title : str</p>
<blockquote>
<div><p>Plot title</p>
</div></blockquote>
<dl class="simple">
<dt>domain<span class="classifier">str (‘freq’, ‘time’)</span></dt><dd><p>Changes the plot style depending on input in frequency or time domain.</p>
</dd>
<dt>order<span class="classifier">int (2, 3, 4)</span></dt><dd><p>Order of the spectrum to be shown.</p>
</dd>
<dt>y_label<span class="classifier">str</span></dt><dd><p>Label of the y axis</p>
</dd>
<dt>x_label<span class="classifier">str</span></dt><dd><p>Label of the x axis</p>
</dd>
<dt>legend<span class="classifier">list</span></dt><dd><p>List of trace names for the legend.</p>
</dd>
<dt>filter_window<span class="classifier">int</span></dt><dd><p>For noisy data the spectra can be convoluted with a gaussian of length filter_window</p>
</dd>
</dl>
<p>Returns the figure.</p>
</dd></dl>

<dl class="py function">
<dt id="QuantumPolyspectra.simulation.second_term">
<code class="sig-prename descclassname">QuantumPolyspectra.simulation.</code><code class="sig-name descname">second_term</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">omega1</span></em>, <em class="sig-param"><span class="n">omega2</span></em>, <em class="sig-param"><span class="n">omega3</span></em>, <em class="sig-param"><span class="n">s_k</span></em>, <em class="sig-param"><span class="n">eigvals</span></em>, <em class="sig-param"><span class="n">enable_gpu</span></em><span class="sig-paren">)</span><a class="headerlink" href="#QuantumPolyspectra.simulation.second_term" title="Permalink to this definition">¶</a></dt>
<dd><p>For the calculation of the erratum correction terms of the S4.
Calculates the second sum as defined in Eq. 109 in 10.1103/PhysRevB.102.119901.</p>
<dl class="simple">
<dt>enable_gpu<span class="classifier">bool</span></dt><dd><p>Specify if GPU should be used</p>
</dd>
<dt>omega1<span class="classifier">float</span></dt><dd><p>Frequency of interest</p>
</dd>
<dt>omega2<span class="classifier">float</span></dt><dd><p>Frequency of interest</p>
</dd>
<dt>omega3<span class="classifier">float</span></dt><dd><p>Frequency of interest</p>
</dd>
<dt>s_k<span class="classifier">array</span></dt><dd><p>Array calculated with :func:small_s</p>
</dd>
<dt>eigvals<span class="classifier">array</span></dt><dd><p>Eigenvalues of the Liouvillian</p>
</dd>
</dl>
<dl class="simple">
<dt>out_sum<span class="classifier">array</span></dt><dd><p>Second correction term as defined in Eq. 109 in 10.1103/PhysRevB.102.119901.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="QuantumPolyspectra.simulation.small_s">
<code class="sig-prename descclassname">QuantumPolyspectra.simulation.</code><code class="sig-name descname">small_s</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">rho_steady</span></em>, <em class="sig-param"><span class="n">a_prim</span></em>, <em class="sig-param"><span class="n">eigvecs</span></em>, <em class="sig-param"><span class="n">eigvec_inv</span></em>, <em class="sig-param"><span class="n">reshape_ind</span></em>, <em class="sig-param"><span class="n">enable_gpu</span></em>, <em class="sig-param"><span class="n">zero_ind</span></em>, <em class="sig-param"><span class="n">gpu_zero_mat</span></em><span class="sig-paren">)</span><a class="headerlink" href="#QuantumPolyspectra.simulation.small_s" title="Permalink to this definition">¶</a></dt>
<dd><p>For the calculation of the erratum correction terms of the S4.
Calculates the small s (Eq. 7) from 10.1103/PhysRevB.102.119901</p>
<dl class="simple">
<dt>zero_ind<span class="classifier">int</span></dt><dd><p>Index of the steadystate eigenvector</p>
</dd>
<dt>enable_gpu<span class="classifier">bool</span></dt><dd><p>Specify if GPU should be used</p>
</dd>
<dt>gpu_zero_mat<span class="classifier">af array</span></dt><dd><p>Zero array stored on the GPU</p>
</dd>
<dt>rho_steady<span class="classifier">array</span></dt><dd><p>A &#64; Steadystate density matrix of the system</p>
</dd>
<dt>a_prim<span class="classifier">array</span></dt><dd><p>Super operator A’ as defined in 10.1103/PhysRevB.98.205143</p>
</dd>
<dt>eigvecs<span class="classifier">array</span></dt><dd><p>Eigenvectors of the Liouvillian</p>
</dd>
<dt>eigvec_inv<span class="classifier">array</span></dt><dd><p>The inverse eigenvectors of the Liouvillian</p>
</dd>
<dt>reshape_ind<span class="classifier">array</span></dt><dd><p>Indices that give the trace of a flattened matrix.</p>
</dd>
</dl>
<dl class="simple">
<dt>s_k<span class="classifier">array</span></dt><dd><p>Small s (Eq. 7) from 10.1103/PhysRevB.102.119901</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="QuantumPolyspectra.simulation.third_term">
<code class="sig-prename descclassname">QuantumPolyspectra.simulation.</code><code class="sig-name descname">third_term</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">omega1</span></em>, <em class="sig-param"><span class="n">omega2</span></em>, <em class="sig-param"><span class="n">omega3</span></em>, <em class="sig-param"><span class="n">s_k</span></em>, <em class="sig-param"><span class="n">eigvals</span></em>, <em class="sig-param"><span class="n">enable_gpu</span></em><span class="sig-paren">)</span><a class="headerlink" href="#QuantumPolyspectra.simulation.third_term" title="Permalink to this definition">¶</a></dt>
<dd><p>For the calculation of the erratum correction terms of the S4.
Calculates the third sum as defined in Eq. 109 in 10.1103/PhysRevB.102.119901.</p>
<dl class="simple">
<dt>enable_gpu<span class="classifier">bool</span></dt><dd><p>Specify if GPU should be used</p>
</dd>
<dt>omega1<span class="classifier">float</span></dt><dd><p>Frequency of interest</p>
</dd>
<dt>omega2<span class="classifier">float</span></dt><dd><p>Frequency of interest</p>
</dd>
<dt>omega3<span class="classifier">float</span></dt><dd><p>Frequency of interest</p>
</dd>
<dt>s_k<span class="classifier">array</span></dt><dd><p>Array calculated with :func:small_s</p>
</dd>
<dt>eigvals<span class="classifier">array</span></dt><dd><p>Eigenvalues of the Liouvillian</p>
</dd>
</dl>
<dl class="simple">
<dt>out_sum<span class="classifier">array</span></dt><dd><p>Third correction term as defined in Eq. 109 in 10.1103/PhysRevB.102.119901.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="QuantumPolyspectra.simulation.time_series_setup">
<code class="sig-prename descclassname">QuantumPolyspectra.simulation.</code><code class="sig-name descname">time_series_setup</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">sc_ops</span></em>, <em class="sig-param"><span class="n">e_ops</span></em><span class="sig-paren">)</span><a class="headerlink" href="#QuantumPolyspectra.simulation.time_series_setup" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a dataframe for storing the simulation results.</p>
<dl class="simple">
<dt>sc_ops<span class="classifier">dict</span></dt><dd><p>Dictionary with all stochastic collapse operators with corresponding names as keys.</p>
</dd>
<dt>e_ops<span class="classifier">dict</span></dt><dd><p>Dictionary with all operators for the calculation of the expectation values with corresponding names as keys.</p>
</dd>
</dl>
<p>Returns a dataframe with columns names like the keys.</p>
</dd></dl>

<span class="target" id="module-QuantumPolyspectra.analysis"></span><dl class="py function">
<dt id="QuantumPolyspectra.analysis.c2">
<code class="sig-prename descclassname">QuantumPolyspectra.analysis.</code><code class="sig-name descname">c2</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">a_w</span></em>, <em class="sig-param"><span class="n">a_w_corr</span></em>, <em class="sig-param"><span class="n">m</span></em>, <em class="sig-param"><span class="n">coherent</span></em><span class="sig-paren">)</span><a class="headerlink" href="#QuantumPolyspectra.analysis.c2" title="Permalink to this definition">¶</a></dt>
<dd><p>calculation of c2 for powerspectrum</p>
</dd></dl>

<dl class="py function">
<dt id="QuantumPolyspectra.analysis.c3">
<code class="sig-prename descclassname">QuantumPolyspectra.analysis.</code><code class="sig-name descname">c3</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">a_w1</span></em>, <em class="sig-param"><span class="n">a_w2</span></em>, <em class="sig-param"><span class="n">a_w3</span></em>, <em class="sig-param"><span class="n">m</span></em><span class="sig-paren">)</span><a class="headerlink" href="#QuantumPolyspectra.analysis.c3" title="Permalink to this definition">¶</a></dt>
<dd><p>calculation of c3 for bispectrum</p>
</dd></dl>

<dl class="py function">
<dt id="QuantumPolyspectra.analysis.c4">
<code class="sig-prename descclassname">QuantumPolyspectra.analysis.</code><code class="sig-name descname">c4</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">a_w</span></em>, <em class="sig-param"><span class="n">a_w_corr</span></em>, <em class="sig-param"><span class="n">m</span></em><span class="sig-paren">)</span><a class="headerlink" href="#QuantumPolyspectra.analysis.c4" title="Permalink to this definition">¶</a></dt>
<dd><p>calculation of c4 for trispectrum</p>
</dd></dl>

<dl class="py function">
<dt id="QuantumPolyspectra.analysis.calc_a_w3">
<code class="sig-prename descclassname">QuantumPolyspectra.analysis.</code><code class="sig-name descname">calc_a_w3</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">a_w_all</span></em>, <em class="sig-param"><span class="n">f_max_ind</span></em>, <em class="sig-param"><span class="n">m</span></em><span class="sig-paren">)</span><a class="headerlink" href="#QuantumPolyspectra.analysis.calc_a_w3" title="Permalink to this definition">¶</a></dt>
<dd><p>Preparation of a_(w1+w2) for the calculation of the bispectrum</p>
</dd></dl>

<dl class="py function">
<dt id="QuantumPolyspectra.analysis.import_data">
<code class="sig-prename descclassname">QuantumPolyspectra.analysis.</code><code class="sig-name descname">import_data</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">path</span></em>, <em class="sig-param"><span class="n">group_key</span></em>, <em class="sig-param"><span class="n">dataset</span></em><span class="sig-paren">)</span><a class="headerlink" href="#QuantumPolyspectra.analysis.import_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Import of .h5 data with format group_key -&gt; data + attrs[dt]</p>
</dd></dl>

</div>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="index.html">QuantumPolyspectra</a></h1>








<h3>Navigation</h3>
<p class="caption"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="current reference internal" href="#">Code Documentation</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="index.html">Documentation overview</a><ul>
      <li>Previous: <a href="index.html" title="previous chapter">Welcome to QuantumPolyspectra’s documentation!</a></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2021, Markus Sifft, Daniel Hägele.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 3.0.3</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="_sources/code.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>